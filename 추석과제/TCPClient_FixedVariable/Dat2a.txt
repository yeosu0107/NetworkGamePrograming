

===============================================
Mon Apr 10 19:54:20 2017
===============================================


//-----------------------------------------
//5장 유틸리티(C++ 표준문서의 한 쳅터)
//pair/tuple - 페어와 튜플
//smart pointer
//data_traits
//chrono - 시간을 재는 함수
//-----------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

using namespace std;


class Model {
public:
	Model() { cout << "생성" << endl; }
	~Model() { cout << "소멸" << endl; }
};

class smartPoint {
	Model* ptr;
public:
	smartPoint(Model* p) : ptr{ p } { }
	~smartPoint() { delete ptr; }
};

void f() {
	Model* p = new Model;

	//예외가 발생
	throw "예외";

	delete p; //예외가 발생하면 delete가 실행되지 않는다.
}


void uf() {
	unique_ptr<Model> p(new Model);
	throw "예외";
}
//스마트포인터의 좋은점


int main()
{
	//try {
	//	f(); //예외를 던질 가능성
	//}
	//catch (char *s) {
	//	cout << "예외발생!" << endl;
	//} //프로그램이 죽지는 않았지만 여전히 delete 실행 X

	try {
		uf(); //예외를 던질 가능성
	}
	catch (char *s) {
		cout << "예외발생!" << endl;
	} //스택에 저장된 객체는 예외발생 시 반드시 소멸됨을 보장 - 스마트포인터(클래스이다)
	//예외 - 정상적인 흐름에서 벗어남
	//예외를 받으면 그대로 catch문에서 그 예외를 처리하고

	save();
}

===============================================
Mon Apr 10 20:00:43 2017
===============================================


//-----------------------------------------
//5장 유틸리티(C++ 표준문서의 한 쳅터)
//pair/tuple - 페어와 튜플
//smart pointer
//data_traits
//chrono - 시간을 재는 함수
//-----------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

using namespace std;


class Model {
public:
	Model() { cout << "생성" << endl; }
	~Model() { cout << "소멸" << endl; }
};

class smartPoint {
	Model* ptr;
public:
	smartPoint(Model* p) : ptr{ p } { }
	~smartPoint() { delete ptr; }
};

void f() {
	smartPoint ptr(new Model);

	//예외가 발생
	throw "예외";

	//delete ptr; //예외가 발생하면 delete가 실행되지 않는다.
}


void uf() {
	unique_ptr<Model> p(new Model);
	throw "예외";
	cout << "예외 이후" << endl;
}
//스마트포인터의 좋은점


int main()
{
	try {
		f(); //예외를 던질 가능성
	}
	catch (char *s) {
		cout << "예외발생!" << endl;
	} 
	//예외 발생 시 발생한 함수에서 빠져나옴
	//함수에서 빠져나오면서 지역객체가 모두 해제됨
	//예외매커니즘은 예외 발생시 이전까지 스택에 저장된 지역객체는 반드시 소멸자가 실행됨을 보증
	//스택 언와인딩을 보증(지역객체의 소멸을 보증) - 위에와 같은말
	//지역객체가 해제되면서 소멸자가 실행 -> 포인터가 딜리트가 된다.

	//스마트 포인터 사용이 아닌 그냥 포인터는 예외 발생시 포인터가 스택에서 사라진다.
	//포인터만 사라지고 힙에 저장된 실제 데이터는 삭제되지 않는다.
	
	save();
}


===============================================
Mon Apr 10 20:21:10 2017
===============================================


//-----------------------------------------
//5장 유틸리티(C++ 표준문서의 한 쳅터)
//pair/tuple - 페어와 튜플
//smart pointer
//data_traits
//chrono - 시간을 재는 함수
//-----------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

using namespace std;


class Model {
public:
	Model() { cout << "생성" << endl; }
	~Model() { cout << "소멸" << endl; }
	void print() { cout << "호출한다" << endl; }
};




//class unipoint {
//public:
//	unipoint(const unipoint& other) = delete;
//};
////생성자를 private에 넣으면 복사생성자 호출이 안된다.
////최신C++은 delete를 해주거나 default 해주면 복사생성자 호출이 안된다.
////래퍼런스를 붙여야지만 돌어감

//함수에서 인자로 부를 때는 그 인자는 복사된다.
//이 때 스마트포인터는 이 복사하는 것을 부정한다. (위의 방법으로)
//->자원을 독점적으로 가지기 때문이다
//그렇기에 무조건 레퍼런스타입으로 인자를 불러야한다.
//래퍼런스를 붙이면 복사를 시키는 것이 아니다.**


void f(unique_ptr<Model>& p) {
	cout << "f함수 끝" << endl;
}

//또는 복사는 안되지만 C++11부터는 소유권을 줘버릴 수도 있다. move**
void f2(unique_ptr<Model> p) {
	cout << "f2함수 끝" << endl;
}
//포인터는 4바이트
//스마트포인터도 4바이트임을 보장해줌
//클래스로 만들었는데 크기가 커지지 않나? 
//-> 오직 맴버면수만이 클래스의 크기의 영향을 미치므로 상관없다.
int main()
{
	unique_ptr<Model> p(new Model);

	f(p);
	cout << "ff" << endl;
	f2(move(p));
	//소유권을 이전해 주었으므로 f2함수가 끝날 때 지역객체가 소멸될 때 p가 소멸됨
	cout << "fff" << endl;
	save();
}